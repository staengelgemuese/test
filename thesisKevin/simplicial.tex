\HeaderOne{Circulation-Preserving, and stable fluids on simplicial complexes}
\label{ch:simplicial}

This chapter briefly outlines the algorithm of \myciteS{elcott}, which is the basis for this thesis.
For simplicity, we will restrict ourselves to two dimensional fluids.
Furthermore, we suppose zero boundary conditions, i.e., there is no in- or out flow of the domain.
Moreover, we assume that the domain consists of a contractible topology.
A topology is contractible if every loop can be contracted to a single point, i.e., there are no holes inside the domain.

\HeaderTwo{The Euler equations}
\label{sec:FluidEquations}
Elcott's algorithm simulates \newword{inviscid} and \newword{incompressible} fluids.
The behavior of such fluids are described by the Euler equations:

\begin{eqnarray}
\label{eq:EulerEquations}
\frac{\partial u}{ \partial t} + ( u \cdot \nabla) u = - \frac{1}{\rho} \nabla P + f \\
\nabla \cdot u = 0
\end{eqnarray}

\myeqref{eq:EulerEquations} can be reformulated in terms of vorticity $\omega := \nabla \times u$ by applying the curl operator:

\begin{equation}
\label{eq:EulerVort}
\frac{\partial \omega}{\partial t} + ( u \cdot \nabla) \omega - ( \omega \cdot \nabla) u = \nabla \times f
\end{equation}

This formulation introduces the vorticity $\omega$, but eliminates the pressure $P$.
For vorticity, there exists an explicit algebraic relation to the velocity, in contrast to the pressure.

\myparagraph{Representation of velocity}
In the paper of Elcott et al., the velocity is a 2P-form in three dimensions.
The form is defined as oriented flow through facets.
Accordingly, in two dimensions the velocity is represented as a 1P-form, i.e., fluxes through edges.
From the incompressibility (div. free), it follows that the sum of the in- and outflows through the edges of a face is zero.

\myparagraph{Representation of vorticity}
Vorticity is derived from the velocity by computing its curl.
The curl operator in DEC has been introduced in Section \ref{sec:VecCalcInDECOps} and is defined on 1-forms, i.e., flux along edges.
Hence, we have to map the velocity 1P-form onto the dual mesh and compute a 1D-form.
Combining both steps leads to:

\begin{equation}
\label{eq:DefCurl}
\DECCurl := d^T *
\end{equation}

Therefore, the form representing the vorticity is a 2D-form.

\HeaderTwo{The basic algorithm}
\label{sec:SimpleAlgorithm}

The algorithm is based on an unconditionally-stable, semi-Lagrangian backward advection strategy as in the work of (\myciteS{ST01}).
Instead of tracking velocities, vorticity integrals are advected along the velocity field.
Vorticity conservation is enforced by applying Kelvins Circulation theorem. 
The velocity is then recovered from the vorticity by solving a Poisson equation.
External forces are treated by adding them with their curl to the vorticity.
This is a consequence of the vorticity formulation (see \myeqref{eq:EulerVort}).
One time step is computed by the following algorithm:

\begin{enumerate}
\item \textbf{Time integration} through vorticity advection
\item Adding \textbf{external forces}
\item \textbf{Recovery} of velocity
\end{enumerate}

\HeaderThree{Vorticity advection}
\label{ssec:TimeIntegration}
The vorticity preserving property of the advection step is based on Kelvins Circulation theorem. 
This can be applied as Stokes theorem establishes a connection between circulation on the boundary and inner vorticities.

\myparagraph{Kelvins Circulation Theorem}
Kelvin's Circulation Theorem states that, the circulation round a material loop $\gamma$, e.g., boundary of a face, is constant.

\begin{equation}
\frac{D}{Dt} ( \int_\gamma u \text{ dl} ) = 0
\end{equation}

Stokes Theorem (see Section \ref{sec:DECDerivative}) states that vorticity acting on a surface is equal to the circulation on the boundary.
Hence, vorticity defined on the dual faces can be advected by moving their respective boundaries along the velocity field.

\myparagraph{Interpolating velocity}
In order to apply advection, a vector field has to be derived from the velocity form.
Every triangle corresponds to three fluxes, which sum up to zero.
Therefore, there exists a unique velocity vector $\mathbf{u}$ for every triangle, s.t. integrated on the edges leads to the same fluxes.
The flux conditions yield three equations.
But the velocity vector consists of two coordinates.
As one equation vanishes (since all three fluxes sum up to zero) the system of equations is uniquely determined.

\myparagraph{Advecting vorticity}
The boundary of a dual face is just a loop of dual edges which are pairwise connected through dual vertices. 
Hence, it suffices to advect only the dual vertices and approximate the circulation acting on the dual edges by interpolating locally the velocity field.

\newpage

\begin{algorithm}
\caption{Advecting vorticity}
\label{alg:VortAdvection}
\begin{algorithmic}

\FORALL{dual vertices $v$}
	\STATE $A_v \gets $ backadvect(v)
\ENDFOR

\FORALL{dual faces $f_D$}
	\STATE $\Omega_f \gets 0$
	\FORALL{dual edges $e_D$ of $f_D$}
		\STATE dual vertices $v_0$ and $v_1$ of $e_D$
		\STATE determine primal faces $f_i$ in which the vertices $A_{v_i}$ are located
		\STATE $\Omega_f +=$relativeOrientation$(e_D,f_D)$ $( A_{v_1} - A_{v_0} )^T \cdot \frac{velVector(f_0) + velVector(f_1)}{2}$ 
	\ENDFOR
\ENDFOR

\end{algorithmic}
\end{algorithm}

\HeaderTwo{Recovering velocity from vorticity}
\label{sec:VortToVel}
In this section, we discuss the recovery of the velocity from given vorticity.
Here, $\DECCurl$ is the curl operator, which has been defined in \myeqref{eq:DefCurl}.
The vorticity 2D-form is identified by $\VorticityForm$ and the velocity 1P-form by $\VelocityForm$.
Obviously, the velocity $\VelocityForm$ has to be a solution of the following equation.

\begin{equation}
\label{eq:SimpleCurl}
\VorticityForm = \DECCurl \VelocityForm
\end{equation}

Mass conservation yields that the velocity is divergence free. Hence, $\VelocityForm$ satisfies:

\begin{equation}
d \VelocityForm = 0
\end{equation} 

Thus, $\VelocityForm$ is a closed form. The topology is contractible and therefore the discrete Poincar√© lemma implies, that $\VelocityForm$ is also an exact form.
A detailed discussion of the lemma can be found in Appendix \ref{ap:PoinCLemma}.
The mass conservation constraint and the exactness of the form $\VelocityForm$ can be combined to a matrix $\DECLaplace$.

\begin{equation}
\label{eq:ComplexCurl}
\DECLaplace \Phi := \DECCurl d \Phi = d^T * d \Phi = \VorticityForm
\end{equation}

For any solution $\Phi$ of \myeqref{eq:ComplexCurl}, $d \Phi$ is a solution of \myeqref{eq:SimpleCurl}.
Moreover, $\VelocityForm = d \Phi$ is divergence free since it is exact and thus closed.
\myeqref{eq:ComplexCurl} is in fact a discrete poisson equation as $*^{-1} \DECLaplace$ is the discrete primal Laplace operator (see Section \ref{para:discreteLaplace}).
%For this reason we denote it by $\DECLaplace$.
For further details on boundary conditions and their implementation see Chapter \ref{ch:boundaryFluxes}.

\paragraph*{}
We briefly presented the algorithm of Elcott et al., which is the basis of this thesis.
In the next chapters we discuss regular grid based implementations and extend the basic version to arbitrary topologies and non-zero boundary fluxes.












%This chapter briefly outlines the stable and circulation preserving simplicial fluid algorithm of Elcott et al.\cite{elcott}. 
%The algorithm consists of three steps: Time integration, adding external forces and recovery of velocity. 
%Time integration is done in the first step by advecting the vorticity along the velocity field. In the second step the external forces are added by their curl. 
%Recovering the velocity from the vorticity is solved in the final step by reformulating the problem as a poisson equation.
%For simplicity, I will restrict in this chapter to the two dimensional case which can be extended to three dimensions.
%Furthermore zero boundary conditions and a trivial topology(no voids) are assumed.
%
%\HeaderTwo{Velocity and vorticity form}
%
%Velocity and vorticity are the involved quantities on which the algorithm is based.
%The velocity is handled by the Navier Stokes equations(see section ~\ref{eq:NSSimple}) which controls the behavior of inviscid and incompressible flows.
%Vorticity is derived from the velocity by computing its infinitesimal curl. The vorticity gets involved by modifying the 
%NS equations to eliminate the pressure term.
%The DEC based representations of the velocity and vorticity are handled in the subsections ~\ref{ssec:NSEq} and ~\ref{ssec:DECForms},
%respectively.
%
%\HeaderThree{Incompressible Navier Stokes Equations}
%\label{ssec:NSEq}
%The behavior of an inviscid and incompressible flow with external forces is described by the following Navier Stokes equations:
%\begin{eqnarray}
%\label{eq:NSSimple}
%\frac{\partial u}{ \partial t} + ( u \cdot \nabla) u = - \frac{1}{\rho} \nabla P + f \\
%\nabla \cdot u = 0
%\end{eqnarray}
%Equation ~\ref{eq:NSSimple} changes into the following by applying the curl operator:
%\begin{equation}
%\label{eq:NSVort}
%\frac{\partial \omega}{\partial t} + ( u \cdot \nabla) \omega - ( \omega \cdot \nabla) u = \nabla \times f
%\end{equation}
%where $\omega := \nabla \times u$ is the vorticity. 
%Equation ~\ref{eq:NSVort} has the advantage that the pressure term vanishes, but leads to the problem of recovering the velocity
%from the vorticity. Though this is solved in section ~\ref{sec:VortToVel}.
%
%
%\HeaderThree{DEC forms}
%\label{ssec:DECForms}
%\myparagraph{Velocity form}
%The velocity field $u$ is in the paper of Elcott given as a primal 2-form in three dimensions.
%Translated into the two dimensional case, the form changes into a primal 1-form.
%Intuitively the velocity field describes the movements of infinite small particles of which a medium is composed of. 
%The velocity represented as a (n-1)P form in a n-dimensional space specifies the oriented flow through a facet.
%The velocity field is incompressible(divergence free). Thus the sum of the in- and outflows of the facets of a n-dimensional simplex is zero.
%
%\myparagraph{Vorticity form}
%The vorticity is in the language of exterior calculus a 2-form. 
%Since the velocity form is encoded as a primal 1-form or 2-form in two- or three-dimensions, respectively, the vorticity form
%is a dual 2-form, as one can see from equation ~\ref{eq:DefCurl}.
%
%\begin{equation}
%\label{eq:DefCurl}
%\text{(n-1)P-Form} \xmapsto{*} \text{1D-Form} \xmapsto{d^T} \text{2D-Form}
%\end{equation}
%
%
%\HeaderTwo{Advecting vorticity}
%
%Advecting the vorticity is the step which computes from the velocity field of the current step the vorticity of the next step.
%
%\HeaderThree{Kelvins Circulation Theorem}
%Kelvin's Circulation Theorem states that, the circulation round a material loop $\gamma$ is constant. I.e.
%\begin{equation}
%\frac{D}{Dt} ( \int_\gamma u \text{ dl} ) = 0
%\end{equation}
%So a loop which is advected along the velocity field conserves the integral of the vorticity which acts on the enclosed surface.
%That is the essential idea, how to advect the vorticity in an nice intrinsic way.
%
%\HeaderThree{Interpolating velocity form}
%In many cases it is necessary to cast local coordinates out of the velocity form, e.g. in the advection process.
%Every triangle corresponds to three fluxes which sum up to zero w.r.t. their orientation in the triangle.
%Therefore exists a unique velocity vector $u$ for every triangle, s.t. integrated on the edges leads to the same fluxes.
%The flux conditions yields three equations. But the velocity vector consists of two coordinates.
%But one equation vanishes since all three fluxes sum up to zero, and thus is the system of equations unique solvable.
%
%\HeaderThree{Advection}
%From Stokes Theorem follows, that the vorticity acting on a surface equals the circulation on the boundary.
%An intrinsic statement about the circulation and its alteration over time is given by Kelvins Theorem.
%Combining both theorems leads to an intrinsic statement about the change of vorticity over time.
%So the vorticity acting on a surface in the next step is achieved by backtracking its boundary and compute the circulation w.r.t. the velocity field of the last step.
%The boundary of a dual face is just a loop of dual edges which are pairwise connected through dual vertices. 
%Hence it suffices to advect only the dual vertices and approximate the circulation of the dual edges.
%
%\begin{algorithm}
%\caption{Advecting vorticity}
%\label{alg:VortAdvection}
%\begin{algorithmic}
%
%\FORALL{dual vertices $v$}
%	\STATE $A_v \gets $ backadvect(v)
%\ENDFOR
%
%\FORALL{dual faces $f$}
%	\STATE $\omega_f \gets 0$
%	\FORALL{dual edges $e$ of $f$}
%		\STATE dual vertices $v_0$ and $v_1$ of $e$
%		\STATE determine primal faces $F_i$ in which vertices $A_{v_i}$ are located
%		\STATE $\omega_f +=$relativeOrientation$(e,f)$ $( A_{v_1} - A_{v_0} )^T \cdot \frac{velVector(F_0) + velVector(F_1)}{2}$ 
%	\ENDFOR
%\ENDFOR
%
%\end{algorithmic}
%\end{algorithm}
%
%\HeaderTwo{Deriving velocity from vorticity}
%\label{sec:VortToVel}
%$C := d^T *$ is the curl operator in DEC, which has been outlined in ~\ref{eq:DefCurl}.
%The advected vorticity is identified with $\omega$ and the desired velocity with $u$.
%The velocity $u$ has obviously to be a solution of the following equation.
%\begin{equation}
%\label{eq:SimpleCurl}
%\omega = C \cdot u
%\end{equation}
%An additional constraint is, that the required velocity form is divergence free. That is $d \cdot u = 0$. 
%That means $u$ is a closed form. Since the domain is void-free, u is also exact, which follows from the discrete Poincar√© lemma.
%A detailed discussion of the lemma can be found in Appendix ~\ref{ap:PoinCLemma}.
%Combining both ideas induces the matrix L.
%\begin{equation}
%\label{eq:ComplexCurl}
%L := C \cdot d = d^T * d
%\end{equation}
%For any solution $\varphi$ of ~\ref{eq:ComplexCurl} is $d \varphi$ also a solution of ~\ref{eq:SimpleCurl}.
%Moreover is $u = d \cdot \varphi$ divergence free since it is exact and thus closed.
%Equation ~\ref{eq:ComplexCurl} is in fact a discrete poisson equation due to $*^{-1} L$ is the discrete primal Laplace operator.
%That is why the matrix is denoted by $L$.
%For further details on boundary conditions and their implementation see section ~\ref{sec:NonTrivialBoundary}.
%
